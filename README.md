```php

                 ** The art of Engineering **
	    
	            * maturing prototypes *
		  
		  
                           0. spark

The physicist programmer might want to make a computer simulation 
for a given model he has in mind, the mathematician could be give 
a try to code his ideas to a computer generated graphical output. 
The hobbyist programmer could want to build a small tool or a video 
game, or a programming language, or whatnot. So a small program pops 
from their fingers, out of pure will, not mandate, of desire 
not of request, not during strict work day ours, it might just aid 
to take something out of insomnia, It comes not to support a business 
or an organization, comes without a budgets, a schedule, without supervisors,
managers, even users. It comes not to satisfy a menial task required for a 
big corp, not ch satisfy an external demand, not to have a definite place to
fill in a coral construction, it doesn’t start from a request of a huge paid
engineering team, collaborating pushed by market demands.

But starts, nonetheless, and if runs kind of right specially under minimal 
expectations, if it shows something interesting, even if barely working, 
the physicist, the hobbyist, the mathematician, gets something back. 
Feedback, a desired or unsuspected response, a digital oracle or an 
abstract machine with its fuel and its work. It gives back a perspective 
on the chosen topic, the program retrieves a panoramic view to the curious 
in exchange of the tribute in lines of code. And crucially, it gives back 
energy to go deeper.

The mental model we had gets more definite, it distills richer questions 
for the oracle, the machine envisioned develops and starts rolling, and 
the creature demands more exploration.

This voracious creature feeds from fingers, mind, time, and code.



                        1.   then light


As closer we are to the a concept model and to the prototype, 
we flight bare bones, fast to code and explore alternatives, 
careless discard of non promising paths and iterate, keeping all 
things simple, pure KISS, architecture to the point of almost 
not existing,  with complete disregard of future changes, expansions, 
and integration to other components. To flight we need lightweight. 
To get a grasp, and a taste, to satisfy our kraftlust, get impulse, 
go head first for an optimistic maybe or even an optimistic yes, 
if you are like me, it will suffice a folder, a zero lag editor 
for programmers, and a non verbose scripting language we know 
for ages, which doesn’t nag us with type declaration, resource 
devouring slow IDEs,  slow compilers. 

No. Just a folder, an editor, and a script.

Then the spark, the file, divides like that magic cell which 
started life. Functions born. Classes enclose affine functions 
as villages. Our spark file gets uncomfortable and splits.

We are moody creatures. 

No corp is taming us to standard compliance. An anarchic spirit 
flows in the code. No one rules our little digital world.

As the song from Michael Nyman claims: 
the heart demanded pleasure first. 

After a few days, if we are sensible fellows, we should feel 
unease of making destructive mistakes, losing files, entering 
a short but painful pathway or a rabbit hole we cannot 
return from. So, a version control system enters the game and 
we get bored we it’s simple albeit bureaucratic setup. 


	          2.           Protos

If we are lucky, and our mind is, at least this time, focal and our 
adventure path is not too foggy, we have a broad direction to trip away. 
If we have a dormant engineer side, a prototype idea can spawn.  A prototype, 
which after construction, in a benevolent environment and the aid of crafty 
hands, can solve a riddle, confirms enough the possibility of an interesting 
machine, a useful one, it can offer a machine that at least partially works 
as desired and could be the base better design explorations. A prototype 
creation that with the proper components around and enough adjustments, 
could bear a real world load and be elevated from a little experiment 
out of curiosity to a key piece to solve a major puzzle, ours or not.

A sensible prototype building grows better and faster with simplicity 
in mind, it is expected to be imperfect and incomplete, to work 
in almost ideal circumstances, its better built lightweight keeping in
mind we might throw it away in a blink, we must waste little 
construction material.

Our prototype material is unfortunately caved from precious time mines.

It’s by nature unstable since its ways to function get clearer only 
after we go deeper. It can foresee internal consistency and structure 
in favor of close season to harvest. It can neglect configuration since 
is has to offer proof of utility on key scenario, not multitudes. 
It serves better from brief, partial hardwired passive, crafted little 
tight function-like components, than from mature but complex components 
hard to integrate.


		3.          Our Domains
		
As a gaucho rastreador in la pampa,a kind of cawboy in the remote 
south of the 19th century, we know our land, what tools we have, 
languages, storage, command line tools, API services, OS, components 
and math. We might adventure beyond our land while prototyping, it's 
a sane exercise to look for components to aleviate the task at hand.
We can find a simple tool with an online search which excuses us from
the mind effort and time to develop something we are in need, and more 
importantly to avoid the hassle of mantaining it after our primal 
tinkering, to mature it, to ensure it meets it's required quality. 
We should, howevever, be aware that we can end up spending more time 
and headaches trying to make work some complex or badly documented
component. That it can take us to a boring path, to feel stalled, 
to hit too many walls and frustrate. We are not doing corp engineered, 
we have limited energy, we are moody, no paycheck outweights 
or dissapointments. 

Worst than taking hard to tame beasts to support ours, is be tempted 
to mix in a  flaming crisol athigh temperatures our wish to learn 
and our determination to build. It's ok to adventure learning throughout
a simple exploratory project, when your objective is to learn, to take 
a shot on a shiny beast to ground our lectures with naif experience but 
we our goal is to build something real, we must expect a delayed timeline 
and a sub par quality due to the lake of expertise we have, due  to be
ignorant of the shadows below the shiny. 

If we are serius about or project, if is probably wiser to stick to 
our domains, and expand it with care, taking advantage of any gently 
fellow's work, who has been kind to share it's work or to expend in
what can saves of much grinding. We can be bold but should be careful 
enough to avoid too many cliffs and foul us to a land which we are 
not competent enough. 

We might lnow that we will benefit from using containers for better 
distributing our load in production but if we are rockies can end up 
losing weeks to get anything done, same for other sexy tech out there. 
it can tiring, disappointing and be unacceptable on our expected 
resources and timeline. Take into account the trade offs you make. 
Avoid mixing too much unknowns, we are optimists to start walking 
unknown paths, and get lost or doom our prototype with unrealiable 
dependencies. Be wise, know your land, delay complexity. 


Big, flexible components from the viewpoint of a little prototype more 
common than not, derives in poor integration, tedious manual procedures 
that ruin rapid tinkering, trials and much needed adjustments. .We must 
be careful to avoid picking seemingly great components alien to our 
experience, with voracious error prone setup times, complex class 
hierarchies, partial documentation or simply put: too many ways of misuse. 

The corp engineer, well seasoned and savant,  will finger at us: do not 
reinvent the wheel, you novice. And that’s an undeniable part of the big 
truth. But still, insist: we can code out of the way our cranky ten lines 
of code logger, or two lines database backup script, our fifty lines 
tightly integrated profiler tool if they sum a tenth of the time and 
the headaches we have to invest to setup a complex and flexible standard 
tool or component. 

Even if a component does a terrific job for a big or even a small corp,  
we don’t forget a corp might count with productive systems experience 
using them, with seasoned specialists with knowledge on the nuances of 
those tool sets, allowing them to have a quick setup and proper user. 
They have also enough work force to withstand and dilute an additional 
load on each member of the team. And with a paycheck, a painful 
development experience can be easily neglected but in our untamed 
project, it can might not be so. 

 We are then likely better of them, we can custom tailor our own tools, 
 as we need them, doing it’s eagle focused minimal jobs, providing it’s 
 exact feedback where need them as long as we are perfectly aware than 
 we will eventually or even likely drop them later when the life 
 expectancy of the prototype or even the project expands. We must be 
 aware of the trade off, if the tool gets too complex, hard to maintain 
 or time consuming, then it’s time to get rid of them. If what seemed 
 simple to craft probed not so, then go for something done, we 
 nonetheless must be wise, and go for something simple enough. 

As always, we have to ponder the best strategy, to build, to take 
something simple, unknown or complex or flexible, and more importantly, 
we must to be open to revert our decision when reality teach us wrong.

Then our child grows. Masons enter to craft their medieval game 
and a cathedral dominates the village. 

Our beloved prototype must suffer a brutal dissection. 


Hardwired

Unforntunely, there are aspects of what takes us beyond a prototype 
that are unconvinient to isolate. Exception handling is one, it just 
polutes our code, it intermixed our success paths with peripherial 
details. A less complex one but still a mess is proper logging. 
We should refrain to fall tempted on depend upon proxies to form 
onions which expands the core with fine grained control. we don't 
use language expansions like aspect oriented programming to enable 
separation of our wired layers. It end ups hard to mantain anyway 
and slow us down. 

Whenever possible, we should try to separate the point from the 
ellipsis, and isolate aspects that might later change, components 
that we depend on, which introduces a foreign API and can pervade 
our code base,slike torage solutions that have that downside. 
We take care to not expose too much our dependencies througout 
or simple, relevant API. 

That doesn't mean to build complex hierarchies and settings files 
to allow the uncertain, we won't foul as with a magic sphere like 
a manusch luck teller, we use simple classes and methods, we prefer 
the static from the dynamic, the particular from the generic, our 
domain from external vocabulary. We shovel, tough  the accesory 
appart when doable, always with simplicity, to avoid getting 
punched repeatedly later through.

We hide our means to retain control of our domain API, we avoid 
to be dominated by an uncomfortable exoskelleton, an unwanted framework. 
We avoid abstracting and interfacing early, we don't create to factories 
unless we must, we don't  face with IoC from start:to avoid cumbersome 
and troubled experience of code, hard to debug code we stay simple, 
we conquer with humble code, as the ancient master Confusius said, 
stay low, be like, the water conquers the rock, be like water.

               
                     3.   Masonry


Role play starts. The artisan, rogue programmer encounters 
the mason architect. We are brought in the dawn of architecture.  
Our beloved prototype must suffer a brutal dissection. 

We get the growingly amorphous albeit promising prototype a look 
from the distance, above, and the cliff. 

Architecture is built around and inside the prototype, major surgery. 
Our inner mason now rules. Our rogue programmer loss or at least 
share its power. To support an ample set of orbiting satellites 
that must to be in place to make it realistically usable; some 
typical ones: make it viable on a production environment, which 
doesn’t necessarily match the comfortable place we use to develop to 
the expected load. Besides, when things go south, take proper care 
of unexpected places we end up, be sure to be prepared to unavoidable 
fall, given enough hints for forensic analysis when or beast hits the 
floor hard. We have to be sure we can meet benchmarks to make it usable. 
We have to make it to play well with robust noble friendly beats, like 
components that proven not to be rusted by use and time. To be robust, 
to fit a good design for our purpose code refactor has to be done or 
-deities save us- rewrote from scratch.

Then the flow starts disappointingly to slow down, someone need to take 
care of boring stuff (hopefully not us, the quick and dirty rogue programmers). 

As Gothic cathedrals needed the invention of contra fortes to aid 
the thin walls to support the outward derivative forces cúpula and 
pinnacles to to direct forces downward; the program needs its structures 
albeit purely abstract, practical on every other sense. 

The architect as person or just as a role play must enter the game 
at the right time, if it comes to early we risk a myriad of non 
useful design attempts since the prototype hasn’t solidified and we 
loose precious, unpaid time. But if he enters to late, the code might 
gone wild, and refactor could be harder than restart from scratch. 
If so, we stall if not just abort the mission and throw a new skeleton 
to the closet. Both mistakes entail risks. 

But get back to the role. The architect, the mason, imposes a load over 
the rogue programmer, the mason robs him to rise  its tribute to please 
the gods of craftlust to an otherwise impossible height. 

If the mason is wise, he doesn’t take too much time from building activities, 
since the workers are few, if not just one; if the imposed structure 
is too big, complex, or hard to navigate, or just to abstract or even to 
metaphorical outside the domain of the project at hand, the constructors 
suffers, slow down, debugging gets cumbersome, and the flow disappears. 

When the structure is untamed, the constructor bears the pain of lurking 
over and over in its own faulty memory to know were to go, to build, 
to debug. Bridging the structural abstractions to factual, active code 
jumps over long rivers. 

Hints of these hard to fix pitfalls appear in the form top down designs. 
Appears in the form of long stack traces, injected code into classes, 
generic alien words like containers, managers, policies, providers 
and factories. Appears, also in sequences of one line function call chain 
and proliferation of interfaces with just a single implementation 
and pattern oriented design. Also appears, in external configuration files 
to prevent future changes to require the slightest code change at all, 
eluding the fact that for a programmer its simpler to write code than 
settings files from XML, YAML, and property files. All the these come 
from a too imaginative, envisioned architect. 

But, the corp, big engineer would say: nonsense! all that stuff 
you mention has its utility and we have successfully built great software 
with clever, powerful and flexible designs. And that is also true, 
for a large team, with tens, hundred or thousand of engineers architect 
and developers the trade off can pay off but don’t forget that you count 
with a hierarchical structure that can force compliance, submission to 
an arbitrarily large or time consuming super structure, easily overlooked 
in company with a paycheck. 

For the rogue folks which builds free from the control and enforcement that 
hierarchy imposes, and without the ability to dilute the work overload over 
a large team and a heart motín can crash the ship, don’t forget: we creative 
programmers on the wild, are moody creatures. 

So, should we build grad cathedrals or modest chapels ? Well, the particulars 
matter, we should judge the trade offs. It seems wiser to build the floor plans, 
to architect, with a bottom up approach which helps to keep the design grounded 
tight to its current demands. And this is closer to a truth as closer we are to 
the prototype. Once the project needs to support divergent demands the converse 
might be more nonsensical.

If we are role playing, a sensible approach is to avoid playing the programmer 
and the architect at the same time. One can derive benefits by holding a notebook 
for sketching design ideas both for current and distant needs. This keep the mason 
at bay. His ideas get heard so he doesn’t get furious and take over the a good 
looking prototype and turn into a design monster.



                        4.	 The Crystal Castle

The prototype works flawless, it flies likes like an eagle, no fail so far, we checked 
and re-checked the math, we played with it's console commands,  it's UI works 
as its due,  we were meticulous safeguarding our little beast from misuse. But it is still 
in the sandbox, no real, heavy load has been lifted. It might work perfectly yet 
it's made from crystal glass, it's brittle in its purity, a like shock will smash 
it into thousand pieces. To stand the teeth of time we must ensure that systemic 
failure won't happen.  What if a networked resource is unavailable or worst,it fails 
after allocation amidst its duty, can we recover ? if our realm needs to work restless,
pleasing moon and sun, we should then give them it's due tribute. We, then, expect failure,
and prepare. Every allocation can fail, should we have redudant resources? then they 
must be properly setup, and taken into account at allocation times. 

The prototype then matures to stand. 

We shall be wise, not making this task casually while programming but taking it appart
we it's due thinking, designs, and programming time, implemented gradually if needed. We
shall keep role playing.

What if a components becomes unrelayable, it starts to lag, it's aid is not ready when needed. 
it times out. Does it break our UI, does the app hangs ? Do we left enough trace of for
forensic analysis in the aftermaths ? Are timeouts properly set for each response according 
to what is needed? Are exceptions handled and reported well enough ? Are they handled 
at the proper layer to allow the system albeit degraded in it's capabilities still on duty ? 

We have to take some time playing the role of analyst of fault tolerance needs, and as architects
design accordingly the components, services, logs , settings, messages and event tracking to withstand 
the punches, and get ormesis on our side.  Some simple tactics might help. Like forcing exceptions 
in the code at different layers and then test them for failure. If we have time and seems worthy, 
we can even design a simple way to force random failures now and then, to keep recovery tatics 
excercised. We might want to track events of sucess and failures on a event tracker service, 
it might be a custom solution like tracking them to a database. We can track our punches with 
critical info like serverity, recovery state (hard fail or recovered), exception messages, 
stack traces, time stamps. We might reset services, web servers, databases or machines to see 
we recover properly. 

To keep everyone calm, it's not enough to log and partial recover if no one handles the bad news. 
If our beast pleases moon and sun gods, then we should use a tool that monitors its availability, 
there are standard open source solutions that checks the health of a system according an specified 
pattern, keeps track of delays, historical info and reporting through instant messaging services 
and email. We can even make our even tracking service to have a descriptive monitor board for 
different parts of the system.

If we do our due, we leave the realm of a crystal prototype and enter 
into the wild lands of production armed to fail with grace.

                                   TO BE CONTINUED


```

